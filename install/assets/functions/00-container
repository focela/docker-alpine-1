#!/command/with-contenv bash
#------------------------------------------------------------------------
# Container Functions Library - Core Utilities for s6-overlay Containers
#
# Purpose: Comprehensive function library providing container initialization,
# service management, logging, database connectivity, template processing,
# and utility functions for s6-overlay based containers.
#
# This library is sourced by initialization scripts and services to provide
# consistent behavior across the container ecosystem.
#
# Note: This script runs in the s6-overlay environment and must preserve
# signal handling, shutdown behavior, and init process expectations.
#------------------------------------------------------------------------

#------------------------------------------------------------------------
# COLOR AND OUTPUT FORMATTING CONSTANTS
#------------------------------------------------------------------------
# ANSI color codes for formatted console output
bdg="\e[42m"    # Background green (INFO)
bdb="\e[44m"    # Background blue (WARN)
bdm="\e[45m"    # Background magenta (DEBUG)
bdgy="\e[100m"  # Background gray (NOTICE)
blr="\e[101m"   # Background light red (ERROR)
boff="\e[49m"   # Reset background color

#------------------------------------------------------------------------
# CONTAINER INITIALIZATION AND SERVICE MANAGEMENT FUNCTIONS
#------------------------------------------------------------------------
# Wait for container initialization scripts to complete
# Checks for the existence of the final initialization marker file
check_container_initialized() {
  print_debug "Checking to see if container initialization scripts have completed"
  output_off
  while [ ! -f /tmp/.container/99-container-init ]; do
    print_debug "Checking to see if container initialization scripts have completed"
    sleep 1
  done
  output_on
}

# Wait for a specific service to initialize
# Args: $1 - service name or "init" for initialization mode
#       $2 - optional specific service name when not in init mode
check_service_initialized() {
  print_debug "Checking to see if service has initialized"
  output_off

  # Determine service initialization mode and bypass logic
  if [ "$1" = "init" ]; then
    service_suffix="-init"
    csi_bypass=FALSE
  else
    service="$1"
    csi_bypass=TRUE
  fi

  # Resolve service name based on context and parameters
  if [ "$csi_bypass" = "FALSE" ]; then
    if [ -z "$2" ]; then
      case "$(dirname "$0")" in
        "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d" )
          service=$(basename "$0")
        ;;
        *)
          service=$(basename "$PWD")
        ;;
      esac
    else
      service=$2
    fi
  fi

  # Wait for service initialization marker file
  while [ ! -f /tmp/.container/"${service}"${service_suffix} ]; do
    sleep 1
    print_debug "Looking for existence of /tmp/.container/${service}${service_suffix}"
  done
  unset csi_bypass
  output_on
}

# Signal completion of service initialization
# Creates marker files to indicate service startup completion
liftoff() {
  output_off
  mkdir -p /tmp/.container

  # Add DONOTSTART prefix if service is disabled
  if [ "$DONOTSTART" = "TRUE" ]; then
    liftoff_prefix="DONOTSTART "
  fi

  # Create appropriate marker file based on script location
  case "$(dirname "$0")" in
    "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d" )
      echo "${liftoff_prefix} $(basename "$0")-init initialized on $(log_prefix)" >> \
        /tmp/.container/"$(basename "$0")"-init
    ;;
    *)
      if [ ! -f /tmp/.container/"$(basename "$PWD")" ]; then
        echo "$(basename "$PWD") initialized on $(log_prefix)" >> /tmp/.container/"$(basename "$PWD")"
      else
        echo "$(basename "$PWD") reinitialized on $(log_prefix)" >> /tmp/.container/"$(basename "$PWD")"
      fi
    ;;
  esac
  output_on
}

# Load defaults and functions for services
# Args: $1 - loading mode (BOTH/DEFAULTS/FUNCTIONS or service name)
#       $2 - specific service name when using modes
prepare_service() {
  if [ -n "$1" ]; then
    case "$(dirname "$0")" in
      "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d" )
        # In initialization directory - auto-export variables
        set -a
        get_defaults "$1"
        get_functions "$1"
        set +a
      ;;
      *)
        # In service directory - handle loading modes
        case "$1" in
          "BOTH" | "both" | "ALL" | "all" )
            get_defaults "$2"
            get_functions "$2"
          ;;
          "DEFAULTS" | "defaults" )
            get_defaults "$2"
          ;;
          "FUNCTIONS" | "functions" )
            get_functions "$2"
          ;;
        esac
      ;;
    esac
  else
    # No arguments - load based on context
    case "$(dirname "$0")" in
      "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d")
        set -a
        get_defaults
        get_functions
        set +a
      ;;
      *)
        get_defaults
      ;;
    esac
  fi
}

# Enable a service by linking it to the services directory
# Args: $1 - service name from /etc/services.available/
service_start() {
  ln -sf /etc/services.available/"${1}" /etc/services.d/
}

# Disable a service by marking it as DONOTSTART
# Args: $1 - service name to disable
service_stop() {
  echo "DONOTSTART added by $(basename \""$0"\")" >> /tmp/.container/"${1}"-init
}

#------------------------------------------------------------------------
# LOGGING AND OUTPUT FUNCTIONS
#------------------------------------------------------------------------
# Generate timestamp prefix for log entries
# Returns formatted timestamp if log prefixes are enabled
log_prefix() {
  output_off
  if [ "${CONTAINER_ENABLE_LOG_PREFIX,,}" = "true" ]; then
    echo "$(date +"${CONTAINER_LOG_PREFIX_DATE_FMT}")${CONTAINER_LOG_PREFIX_SEPERATOR}$(date +"${CONTAINER_PROCESS_HELPER_TIME_FMT}") "
  fi
  output_on
}

# Disable bash debug output temporarily
# Used to prevent debug noise during specific operations
output_off() {
  if [ "${DEBUG_MODE,,}" = "true" ]; then
    set +x
  fi
}

# Re-enable bash debug output based on script context
# Selectively enables debug output avoiding init script noise
output_on() {
  if [ "${DEBUG_MODE,,}" = "true" ]; then
    case "$(basename "$0")" in
      0*-* | 99-* )
        # Skip debug for init scripts (00-* and 99-*)
        :
      ;;
      run )
        case "$PWD" in
          */0*-* | 99-* )
            :
          ;;
          * )
            set -x
          ;;
        esac
      ;;
      * )
        set -x
      ;;
    esac
  fi
}

# Print debug level log messages
# Args: $1 - debug message to print
print_debug() {
  output_off
  case "${CONTAINER_LOG_LEVEL,,}" in
    "debug" )
      if [ "${DEBUG_MODE,,}" = "true" ]; then
        if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
          echo -e "$(log_prefix)[DEBUG] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
        else
          echo -e "$(log_prefix)${bdm}[DEBUG]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
        fi
      else
        if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
          echo -e "$(log_prefix)[DEBUG] ** [${PROCESS_NAME}] $1"
        else
          echo -e "$(log_prefix)${bdm}[DEBUG]${boff} ** [${PROCESS_NAME}] $1"
        fi
      fi
    ;;
  esac

  case "${CONTAINER_LOG_FILE_LEVEL,,}" in
    "debug" )
      echo -e "$(log_prefix)[DEBUG] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1" >> \
        "${CONTAINER_LOG_FILE_PATH}"/"${CONTAINER_LOG_FILE_NAME}"
    ;;
  esac
  output_on
}

# Print error level log messages with light red background
# Args: $1 - error message to print
print_error() {
  output_off
  case "${CONTAINER_LOG_LEVEL,,}" in
    "debug" | "notice" | "warn" | "error")
      if [ "${DEBUG_MODE,,}" = "true" ]; then
        if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
          echo -e "$(log_prefix)[ERROR] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
        else
          echo -e "$(log_prefix)${blr}[ERROR]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
        fi
      else
        if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
          echo -e "$(log_prefix)[ERROR] ** [${PROCESS_NAME}] $1"
        else
          echo -e "$(log_prefix)${blr}[ERROR]${boff} ** [${PROCESS_NAME}] $1"
        fi
      fi
    ;;
  esac

  case "${CONTAINER_LOG_FILE_LEVEL,,}" in
    "debug" | "notice" | "warn" | "error")
      echo -e "$(log_prefix)[ERROR] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1" >> \
        "${CONTAINER_LOG_FILE_PATH}"/"${CONTAINER_LOG_FILE_NAME}"
    ;;
  esac
  output_on
}

# Print info level log messages with green background
# Always logs to file regardless of log level
# Args: $1 - info message to print
print_info() {
  output_off
  if [ "${DEBUG_MODE,,}" = "true" ]; then
    if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
      echo -e "$(log_prefix)[INFO] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
    else
      echo -e "$(log_prefix)${bdg}[INFO]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
    fi
  else
    if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
      echo -e "$(log_prefix)[INFO] ** [${PROCESS_NAME}] $1"
    else
      echo -e "$(log_prefix)${bdg}[INFO]${boff} ** [${PROCESS_NAME}] $1"
    fi
  fi

  echo -e "$(log_prefix)[INFO] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1" >> \
    "${CONTAINER_LOG_FILE_PATH}"/"${CONTAINER_LOG_FILE_NAME}"
  output_on
}

# Print notice level log messages with gray background
# Args: $1 - notice message to print
print_notice() {
  output_off
  case "${CONTAINER_LOG_LEVEL,,}" in
    "debug" | "notice" )
      if [ "${DEBUG_MODE,,}" = "true" ]; then
        if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
          echo -e "$(log_prefix)[NOTICE] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
        else
          echo -e "$(log_prefix)${bdgy}[NOTICE]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
        fi
      else
        if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
          echo -e "$(log_prefix)[NOTICE] ** [${PROCESS_NAME}] $1"
        else
          echo -e "$(log_prefix)${bdgy}[NOTICE]${boff} ** [${PROCESS_NAME}] $1"
        fi
      fi
    ;;
  esac

  case "${CONTAINER_LOG_FILE_LEVEL,,}" in
    "debug" | "notice" )
      echo -e "$(log_prefix)[NOTICE] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1" >> \
        "${CONTAINER_LOG_FILE_PATH}"/"${CONTAINER_LOG_FILE_NAME}"
    ;;
  esac
  output_on
}

# Print service startup messages with process counter and runaway protection
# Implements restart counting and automatic service disabling for runaway processes
# Args: $1 - startup message to print
print_start() {
  output_off

  # Process counter and restart tracking
  if [ "${CONTAINER_ENABLE_PROCESS_COUNTER,,}" = "true" ]; then
    if [ -f /tmp/.container/"$(basename $PWD)" ]; then
      proc_start_count=$(cat /tmp/.container/"$(basename $PWD)" | wc -l)
      proc_start_wrapper="[${proc_start_count}] "
    fi

    if [ -z "${proc_start_count}" ]; then proc_start_count=1; fi

    # Process helper integration for external monitoring
    proc_help_arg="$(date +"${CONTAINER_PROCESS_HELPER_DATE_FMT}") $(date +"${CONTAINER_PROCESS_HELPER_TIME_FMT}") $(basename "$(pwd)") ${proc_start_count} $(cat /etc/hostname)"
    if [ -d "${CONTAINER_PROCESS_HELPER_PATH}" ]; then
      if [ -f "${CONTAINER_PROCESS_HELPER_PATH}"/"$(basename $0)".sh ]; then
        exec "${CONTAINER_PROCESS_HELPER_PATH}"/"$(basename $0)".sh "${proc_help_arg}"
      elif [ -f "${CONTAINER_PROCESS_HELPER_PATH}"/"${CONTAINER_PROCESS_HELPER_SCRIPT}".sh ]; then
        exec "${CONTAINER_PROCESS_HELPER_PATH}"/"${CONTAINER_PROCESS_HELPER_SCRIPT}".sh "${proc_help_arg}"
      fi
    fi

    # Runaway process protection - automatically disable services that restart too frequently
    if [ "${CONTAINER_PROCESS_RUNAWAY_PROTECTOR,,}" = "true" ]; then
      if [ "${CONTAINER_PROCESS_RUNAWAY_SHOW_OUTPUT_FINAL,,}" = "true" ]; then
        if [ "${proc_start_count}" -eq "${CONTAINER_PROCESS_RUNAWAY_LIMIT}" ]; then SHOW_OUTPUT=TRUE; fi
      fi
      if [ "${proc_start_count}" -gt "${CONTAINER_PROCESS_RUNAWAY_LIMIT}" ]; then
        print_error "POTENTIAL RUNWAY DETECTECTED: Disabling $(basename $PWD) service because it has tried restarting '${CONTAINER_PROCESS_RUNAWAY_LIMIT}' times"
        s6-svc -d /var/run/s6/legacy-services/$(basename "$PWD")
        sleep 3
        exit 1
      fi
      print_debug "[process_restart] - Sleeping for ${CONTAINER_PROCESS_RUNAWAY_DELAY} seconds"
      if [ "${proc_start_count}" -gt 1 ]; then sleep "${CONTAINER_PROCESS_RUNAWAY_DELAY}"; fi
    fi
  fi

  # Print startup message with formatting
  if [ "${DEBUG_MODE,,}" = "true" ]; then
    if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
      echo -e "$(log_prefix)[STARTING] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] ${proc_start_wrapper}$1"
    else
      echo -e "$(log_prefix)${bdg}[STARTING]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] ${proc_start_wrapper}$1"
    fi
    echo -e "$(log_prefix)[STARTING] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] ${proc_start_wrapper}$1" >> \
      "${CONTAINER_LOG_FILE_PATH}"/"${CONTAINER_LOG_FILE_NAME}"
  else
    if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
      echo -e "$(log_prefix)[STARTING] ** [${PROCESS_NAME}] ${proc_start_wrapper}$1"
    else
      echo -e "$(log_prefix)${bdg}[STARTING]${boff} ** [${PROCESS_NAME}] ${proc_start_wrapper}$1"
    fi
    echo -e "$(log_prefix)[STARTING] $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] ${proc_start_wrapper}$1" >> \
      "${CONTAINER_LOG_FILE_PATH}"/"${CONTAINER_LOG_FILE_NAME}"
  fi
  output_on
}

# Print warning level log messages with blue background
# Args: $1 - warning message to print
print_warn() {
  output_off
  case "${CONTAINER_LOG_LEVEL,,}" in
    "debug" | "notice" | "warn" )
      if [ "${DEBUG_MODE,,}" = "true" ]; then
        if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
          echo -e "$(log_prefix)[WARN] ** [${PROCESS_NAME}] $1"
        else
          echo -e "$(log_prefix)${bdb}[WARN]${boff} $SCRIPTPATH/$(basename "$0") ** [${PROCESS_NAME}] $1"
        fi
      else
        if [ "${CONTAINER_COLORIZE_OUTPUT,,}" = "false" ]; then
          echo -e "$(log_prefix)[WARN] ** [${PROCESS_NAME}] $1"
        else
          echo -e "$(log_prefix)${bdb}[WARN]${boff} ** [${PROCESS_NAME}] $1"
        fi
      fi
    ;;
  esac

  case "${CONTAINER_LOG_FILE_LEVEL,,}" in
    "debug" | "notice" | "warn" )
      echo -e "$(log_prefix)[WARN] ** [${PROCESS_NAME}] $1" >> \
        "${CONTAINER_LOG_FILE_PATH}"/"${CONTAINER_LOG_FILE_NAME}"
    ;;
  esac
  output_on
}

# Execute commands silently unless in debug mode or output is explicitly requested
# Args: $@ - command and arguments to execute
silent() {
  if [ "${DEBUG_MODE}" = "true" ] || [ "${SHOW_OUTPUT,,}" = "true" ] || [ "${CONTAINER_LOG_LEVEL,,}" = "debug" ]; then
    "$@"
  else
    "$@" > /dev/null 2>&1
  fi
}

# Display container banner with image information
# Uses base64 encoded ASCII art for startup banner display
showoff() {
  output_off
  if [ -n "${IMAGE_NAME}" ]; then
    iv=$(get_image_version)
    # Base64 encoded: "ðŸš€ " prefix
    is="$(echo 'H4sIAAAAAAAAA/PMTUxPtVLgAgDj9n4BCAAAAA==' | base64 -d | gunzip) ${IMAGE_NAME}"
    if [ ! -z "${iv// }" ]; then
      # Base64 encoded: " (" and ")" for version
      is="${is}$(echo 'H4sIAAAAAAAAA1OoUQhLLSrOzM9TUOACAAiVoSgNAAAA' | base64 -d | gunzip)${iv}$(echo 'H4sIAAAAAAAAA1MIqSxIVVDPzE1MT41PzkjMS0/NyU9XV0jLL1JISS1JzMwp5gIAZRrZYCQAAAA=' | base64 -d | gunzip)"
    fi
    is="${is}"
    if [ -n "${IMAGE_REPO_URL}" ]; then
      # Base64 encoded: "ðŸ“¦ Repository: " prefix
      ir="$(echo 'H4sIAAAAAAAAAwtKLcgvzizJL6rUd8lPLs1NzStJLMnMz7PiAgAxTVbtGgAAAA==' | base64 -d | gunzip) ${IMAGE_REPO_URL}"
    fi
  fi
  # Base64 encoded ASCII art banner
  echo "H4sIAAAAAAAAA61RQRLEIAi78wpvXAq971t68CE8vgni2s7urWUGEyRBHVt7JTYzc+Ga4WD+T+Q/pm9jmQNbIZpNN9OOpGSqnA6I4jJlp1RZZ2OZUbrK3B9nxWw5VB9NiOFNCt5ta8s0kSD3suiBxOQDRh0WxSWQcbuYj9Mp4KuksKAoOVm3qlvRfq1Vl4Nj5fkvZnCsnEeFItgXAgAA" | base64 -d | gunzip
  echo "${is}"
  echo "${ir}"
  # Base64 encoded separator line
  echo "H4sIAAAAAAAAA/PJTE7NK061UvD1DFGoUTi0UsHIwMhEwSWxLFXBOT+vKL+SCwCc9R6MIwAAAA==" | base64 -d | gunzip
  echo ""
  # Base64 encoded footer message
  echo "H4sIAAAAAAAAA22MsRXCMAwF+0zxB4DQ01JRMISIZdDDtowkJy/bkwG46t4Vd8+Itzik0ovRTVdJ7Nh1YKUyGDjjps2PavB+mJq0F+qOTe2DrIZFW0gbnDAlXrlor9zihJDKZcfoiYL9BGoJmSmGMYy/gz18Pu61si1CBT56VwvQSlLoWXieJvzhocfh3rJegXdE9+vlsm3bHGKcNEvMC00/MF6uwtoAAAA=" | base64 -d | gunzip
  echo ""
  output_on
}

#------------------------------------------------------------------------
# GIT AND REPOSITORY MANAGEMENT FUNCTIONS
#------------------------------------------------------------------------
# Clone a git repository with branch/tag support
# Handles repository naming, destination paths, and submodule initialization
# Args: $1 - repository URL
#       $2 - branch/tag/commit (optional)
#       $3 - destination path (optional, defaults to /usr/src/<repo_name>)
clone_git_repo() {
  set +x
  if [ ${DEBUG_MODE,,} = "true" ]; then set -x; fi

  # Verify git is available
  if ! [ -x "$(command -v git)" ]; then
    echo '[clone_git_repo] Git is not installed'
    exit 1
  else
    git config --global init.defaultBranch main
  fi

  if [ -n "$1" ]; then
    # Determine destination path and repository name
    if [ -n "${3}" ]; then
      repo="${3}/"
      repo_text="to '${3}'"
      repo_name="$(echo ${1,,} | sed -e "s|-|_|g" -e "s|\.git||g" | awk -F/ '{print $NF}' | sed 's/[^a-zA-Z0-9_]//g')"
    else
      repo="/usr/src/$(echo ${1,,} | sed -e "s|-|_|g" -e "s|\.git||g" | awk -F/ '{print $NF}' | sed 's/[^a-zA-Z0-9_]//g')"
      repo_name="$(echo ${1,,} | sed -e "s|-|_|g" -e "s|\.git||g" | awk -F/ '{print $NF}' | sed 's/[^a-zA-Z0-9_]//g')"
    fi

    # Export environment variables for source path references
    export GIT_REPO_SRC=${GIT_REPO_SRC:-"${repo}"}
    export GIT_REPO_SRC_${repo_name^^}="${repo}"

    # Check for existing directory
    if [ -d "${repo}" ]; then
      echo "[clone_git_repo] Directory ${repo_path}${repo} already exists. Cannot clone"
      exit 1
    else
      # Ensure .git suffix for proper URL handling
      if [[ $1 == *".git" ]]; then
        :
      else
        append_git_prefix=".git"
      fi

      # Clone repository with shallow fetch for performance
      mkdir -p "${repo}"
      cd "${repo}"
      git init .
      git remote add origin "${1}"${append_git_prefix}
      if [ -n "${2}" ]; then repo_commit="${2}"; fi
      echo "[clone_git_repo] Cloning Git Repo '${1}' '${2}' ${repo_text}"
      git fetch --depth=1 origin ${2} +refs/tags/*:refs/tags/*
      git fetch --depth 1 origin ${2}
      git -c advice.detachedHead=false checkout FETCH_HEAD
      git submodule update --init
    fi
  else
    echo "[clone_git_repo] You tried to call the function but there's no arguments"
    exit 1
  fi
  set -x
}

#------------------------------------------------------------------------
# LOGROTATE AND FILE MANAGEMENT FUNCTIONS
#------------------------------------------------------------------------
# Create a logrotate configuration file for a service
# Args: $1 - configuration file name
#       $2 - log file path to rotate
#       $3 - optional logship parser name
#       $4 - optional user for rotation
#       $5 - optional group for rotation (requires $4)
create_logrotate() {
  if [ -n "$1" ] && [ -n "$2" ]; then
    if [ ! -f /assets/logrotate/"$1" ]; then
      print_debug "Creating Logrotate Entry for $2"

      # Optional logship parser configuration
      if [ -n "$3" ]; then
        if [ "${3,,}" != "none" ]; then
          lrlsparser="# logship: $3"
        fi
      fi

      # Optional user/group specification
      if [ -n "$4" ] && [ -n "$5" ]; then
        lruser="    su $4 $5"
      fi

      if [ ! -d "/assets/logrotate" ]; then
        mkdir -p /assets/logrotate
      fi

      # Generate logrotate configuration
      cat <<EOF > /assets/logrotate/"${1}"
${lrlsparser}
$2 {
    missingok
${lruser}
}
EOF
      chown root:root /assets/logrotate/"${1}"
      chmod 0644 /assets/logrotate/"${1}"
    else
      print_debug "Skipping creating automatic logrotation for ${1}"
    fi
  fi
}

# Copy custom files from source to destination with optional ownership
# Args: $1 - destination path (or source if $2 provided)
#       $2 - optional destination path
#       $3 - optional user for ownership
#       $4 - optional group for ownership (requires $3)
custom_files() {
  if [ -n "${2}" ]; then
    ccustom_files_source="${1}"
    ccustom_files_destination="${2}"
  else
    ccustom_files_source="${CONTAINER_CUSTOM_PATH}"
    ccustom_files_destination="${1}"
  fi

  if [ -d "${ccustom_files_source}" ] && dir_notempty "${ccustom_files_source}"; then
    print_debug "Custom Files: Copying files from '${ccustom_files_source}' to '${ccustom_files_destination}'"
    if [ -d "${ccustom_files-destination}" ]; then
      mkdir -p "${ccustom_files-destination}"
    fi
    cp -aR "${ccustom_files_source}"/* "${ccustom_files_destination}"/
  fi

  # Set ownership if specified
  if [ -n "${3}" ]; then permbuilder="${3}"; fi
  if [ -n "${4}" ]; then permbuilder="${3}:${4}"; fi
  if [ -n "${permbuilder}" ]; then chown -R "${permbuilder}" "${2}"; fi
}

# Execute custom scripts from specified directory
# Args: $1 - optional custom scripts directory path
custom_scripts() {
  if [ -n "${1}" ]; then
    ccustom_scripts_source="${1}"
  else
    ccustom_scripts_source="${CONTAINER_CUSTOM_SCRIPTS_PATH}"
  fi

  if [ -d "${ccustom_scripts_source}" ] && dir_notempty "${ccustom_scripts_source}"; then
    for ccustom_script in "${ccustom_scripts_source}"/*.sh; do
      if [ -x "$ccustom_script" ] && [ ! -d "$ccustom_script" ]; then
        print_debug "Custom Script executing: '${ccustom_script}'"
        ${ccustom_script}
      fi
    done
  fi
}

# Check if directory is empty
# Args: $1 - directory path to check
# Returns: 0 if empty, 1 if not empty
dir_empty() {
  [ ! -n "$(ls -A "$1" 2>/dev/null)" ]
}

# Check if directory is not empty
# Args: $1 - directory path to check
# Returns: 0 if not empty, 1 if empty
dir_notempty() {
  [ -n "$(ls -A "$1" 2>/dev/null)" ]
}

#------------------------------------------------------------------------
# TEMPLATE PROCESSING FUNCTIONS
#------------------------------------------------------------------------
# Install a template file with proper permissions and ownership
# Args: $1 - owner:group specification
#       $2 - source template file path
#       $3 - destination file path
#       $4 - optional file mode (defaults to 0644)
install_template() {
  if [ -z "$1" ] || [ -z $2 ] || [ -z $3 ]; then
    print_error "[install_tempalte] No arguments passed"
    exit 1
  fi

  local template_mode=${4:-"0644"}
  if [ ! -f "$2" ]; then
    print_error "[install_template] Can't find ${2}"
    exit 1
  fi

  if [ ! -d "$(dirname $3)" ]; then
    mkdir -p "$(dirname $3)"
  fi

  chmod "${template_mode}" "${3}"
  chown "${1}" "${DEST}"
}

# Transform environment variables ending in _FILE to read from file contents
# Supports Docker secrets pattern where sensitive values are stored in files
# Args: $@ - space-separated list of variable names to transform
transform_file_var() {
  local variables
  variables=$(echo "$@" | tr " " "\n")
  for variable in $variables; do
    if [ -v "${variable}"_FILE ]; then
      file_variable=${variable}_FILE
      if [ ! -f "${!file_variable}" ]; then
        print_error "[transform_file_var] ${variable}_FILE set as environment variable, however file doesn't exist"
        return 1
      fi
      export "${variable}"="$(cat "${!file_variable}")"
    fi
  done
  unset file_variable
  unset variables
}

# Update template files by replacing {{VARIABLE}} placeholders with actual values
# Uses envsubst for secure variable substitution with proper user context
# Args: $1 - space-separated list of template files to process
#       $@ - remaining args are variable names to substitute
update_template() {
  template_files=${1}
  templates=$(echo "${template_files}" | tr " " "\n")
  shift

  for template_file in $templates; do
    [[ ! -f "${template_file}" ]] && return 1

    template_variables=($@)
    template_user=$(stat -c %U "${template_file}")
    template_tmp_file=$(mktemp)
    cp -a "${template_file}" "${template_tmp_file}"

    # Convert {{VARIABLE}} format to ${VARIABLE} for envsubst
    for template_variable in ${template_variables[@]}; do
      sed -ri "s/[{]{2}$template_variable[}]{2}/\${$template_variable}/g" "${template_tmp_file}"
      print_debug "[update_template] Template: '${template_file}' updating field '${template_variable}'"
    done

    # Perform substitution as the template file owner for security
    (
      export ${template_variables[@]}
      local IFS=":"; sudo -HEu ${template_user} envsubst "${template_variables[*]/#/$}" < "${template_tmp_file}" > "${template_file}"
    )

    rm -f "${template_tmp_file}"
  done
}

#------------------------------------------------------------------------
# WAITING AND POLLING FUNCTIONS
#------------------------------------------------------------------------
# Wait for a directory to exist
# Args: $1 - directory path to wait for
wait_for_directory() {
  print_debug "Looking for existence of directory: $1"
  while [ ! -d "${1}" ]; do
    sleep 1
  done
}

# Wait for a file to exist
# Args: $1 - file path to wait for
wait_for_file() {
  print_debug "Looking for existence of file: $1"
  while [ ! -f "${1}" ]; do
    sleep 1
  done
}

# Wait for a socket to exist
# Args: $1 - socket path to wait for
wait_for_socket() {
  print_debug "Looking for existence of socket: $1"
  while [ ! -S "${1}" ]; do
    sleep 1
  done
}

# Wait for a network port to be available
# Args: $1 - hostname or IP address
#       $2 - port number
wait_for_port() {
  print_debug "Looking for existence of listening port on $1:$2"
  counter=0
  while ! (nc -z "${1}" "${2}"); do
    sleep 5
    (( counter+=5 ))
    print_warn "Host '${1}' is not listening on port '${2}', retrying.. ($counter seconds so far)"
  done
}

#------------------------------------------------------------------------
# DOCKER SECRETS AND ENVIRONMENT HANDLING
#------------------------------------------------------------------------
# Handle Docker secrets by reading from _FILE environment variables
# Supports the Docker secrets pattern for sensitive data
# Args: $1 - variable name to process
#       $2 - optional default value
file_env() {
  if [ "${CONTAINER_ENABLE_DOCKER_SECRETS,,}" = "true" ]; then
    local var="$1"
    local fileVar="${var}_FILE"
    local def="${2:-}"
    local val="$def"

    if [ "${!fileVar:-}" ]; then
      val="$(cat "${!fileVar}")"
    elif [ "${!var:-}" ]; then
      val="${!var}"
    fi

    if [ -z "${val}" ]; then
      print_error "error: neither $var nor $fileVar are set but are required"
      exit 1
    fi
    export "$var"="$val"
    unset "$fileVar"
  fi
}

#------------------------------------------------------------------------
# CONFIGURATION AND DEFAULTS LOADING
#------------------------------------------------------------------------
# Load default configuration files for services
# Supports loading all defaults, specific services, or service categories
# Args: $1 - optional loading mode or service name
get_defaults() {
  if [ -n "$1" ]; then
    case "${1,,}" in
      "all" )
        # Load all available default configurations
        for d in /assets/defaults/*; do
          print_debug "Container: Getting defaults for '${d}' ALL"
          # shellcheck source=/assets/defaults/
          case "$(basename "${d}")" in
            0*-* | 99-* )
              # Suppress debug output for init scripts
              output_off
              source "${d}"
              output_on
            ;;
            * )
              source "${d}"
            ;;
          esac
        done
      ;;
      "app" | "single" )
        # Load defaults for current script/service
        case "$(dirname "$0")" in
          "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d" )
            if [ -f "/assets/defaults/$(basename "$0")" ]; then
              print_debug "Container: Getting defaults for '$(basename "$0")'"
              # shellcheck source=/assets/defaults/
              case "$(basename "$0")" in
                0*-* | 99-* )
                  output_off
                  source /assets/defaults/"$(basename "$0")"
                  output_on
                ;;
                * )
                  source /assets/defaults/"$(basename "$0")"
                ;;
              esac
            else
              print_debug "Container: No defaults available for '$(basename "$0")'"
            fi
          ;;
          *)
            if [ -f "/assets/defaults/$(basename "$PWD")" ]; then
              print_debug "Container: Getting defaults for '$(basename "$PWD")'"
              # shellcheck source=/assets/defaults/
              case "$(basename "$PWD")" in
                0*-* | 99-* )
                  output_off
                  source /assets/defaults/"$(basename "$PWD")"
                  output_on
                ;;
                * )
                  source /assets/defaults/"$(basename "$PWD")"
                ;;
              esac
            else
              print_debug "Container: No defaults available for $(basename "$PWD")"
            fi
          ;;
        esac
      ;;
      * )
        # Load specific comma-separated list of defaults
        defaults=$(echo "$1" | tr "," "\n")
        for d in $defaults; do
          if [ -f "/assets/defaults/${d}" ]; then
            print_debug "Container: Getting defaults for $d"
            # shellcheck source=/assets/defaults/
            case "${d}" in
              0*-* | 99-* )
                output_off
                source /assets/defaults/"${d}"
                output_on
              ;;
              * )
                source /assets/defaults/"${d}"
              ;;
            esac
          else
            print_debug "Container: No defaults available for '${d}'"
          fi
        done
      ;;
    esac
  else
    # Load all defaults when no argument provided
    for d in /assets/defaults/*; do
      print_debug "Container: Getting defaults for $d"
      # shellcheck source=/assets/defaults/
      case "$(basename "${d}")" in
        0*-* | 99-* )
          output_off
          source /assets/defaults/00-container
          source "${d}"
          output_on
        ;;
        * )
          source /assets/defaults/00-container
          source "${d}"
        ;;
      esac
    done
  fi
}

# Load function libraries for services
# Supports loading all functions, specific services, or service categories
# Args: $1 - optional loading mode or service name
get_functions() {
  if [ -n "$1" ]; then
    case "${1,,}" in
      "all" )
        # Load all available function libraries (except this one)
        for f in /assets/functions/*; do
          if [ "$f" != "/assets/functions/00-container" ]; then
            print_debug "Container: Getting functions for '${f}'"
            # shellcheck source=/assets/functions/
            source "$f"
          fi
        done
      ;;
      "app" | "single" )
        # Load functions for current script/service
        case "$(dirname "$0")" in
          "/var/run/s6/etc/cont-init.d" | "/etc/cont-init.d" )
            if [ -f "/assets/functions/$(basename "$0")" ]; then
              print_debug "Container: Getting functions for '$(basename "$0")'"
              # shellcheck source=/assets/functions/
              source /assets/functions/"$(basename "$0")"
            else
              print_debug "Container: No functions available for '$(basename "$0")'"
            fi
          ;;
          *)
            if [ -f "/assets/functions/$(basename "$PWD")" ]; then
              print_debug "Container: Getting functions for '$(basename "$PWD")'"
              # shellcheck source=/assets/functions/
              source /assets/functions/"$(basename "$PWD")"
            else
              print_debug "Container: No functions available for $(basename "$PWD")"
            fi
          ;;
        esac
      ;;
      * )
        # Load specific comma-separated list of functions
        functions=$(echo "$1" | tr "," "\n")
        for f in $functions; do
          if [ -f "/assets/functions/${f}" ]; then
            print_debug "Container: Getting functions for $f"
            # shellcheck source=/assets/functions/
            source /assets/functions/"${f}"
          else
            print_debug "Container: No functions available for '$f'"
          fi
        done
      ;;
    esac
  else
    # Load all functions when no argument provided (except this one)
    for f in /assets/functions/*; do
      if [ "$f" != "/assets/functions/00-container" ]; then
        print_debug "Container: Getting functions for $f"
        # shellcheck source=/assets/functions/
        source "${f}"
      fi
    done
  fi
}

#------------------------------------------------------------------------
# VERSION AND IMAGE INFORMATION FUNCTIONS
#------------------------------------------------------------------------
# Extract version information from changelog files
# Searches multiple potential changelog file naming patterns
get_image_version() {
  output_off
  if [ -n "${IMAGE_NAME}" ]; then
    # Try various changelog file naming patterns
    if [ -f "/assets/.changelogs/${IMAGE_NAME/\//_}.md" ]; then
      image_version=$(head -n1 /assets/.changelogs/${IMAGE_NAME/\//_}.md | awk '{print $2}')
    elif [ -f /assets/.changelogs/docker-${IMAGE_NAME/\//_}.md ]; then
      image_version=$(head -n1 /assets/.changelogs/docker-${IMAGE_NAME/\//_}.md | awk '{print $2}')
    else
      if [ -f /assets/.changelogs/focela_docker-${IMAGE_NAME/\//_}.md ]; then
        image_version=$(head -n1 /assets/.changelogs/docker-${IMAGE_NAME/\//_}.md | awk '{print $2}')
      else
        # Try repository URL based naming
        strip_image_repo_url=$(echo ${IMAGE_REPO_URL%/} | sed "s#https://github.com/##g")
        if [ -f /assets/.changelogs/${strip_image_repo_url/\//_}.md ]; then
          image_version=$(head -n1 /assets/.changelogs/${strip_image_repo_url/\//_}.md | awk '{print $2}')
        fi
      fi

      # Final fallback for focela naming
      if [ -f /assets/.changelogs/focela_docker-${IMAGE_NAME/\//_}.md ]; then
        image_version=$(head -n1 /assets/.changelogs/focela_docker-${IMAGE_NAME/\//_}.md | awk '{print $2}')
      fi
    fi

    if [ -n "${image_version}" ]; then
      echo "${image_version}"
    fi
  fi
  output_on
}

#------------------------------------------------------------------------
# SYSTEM CONFIGURATION FUNCTIONS
#------------------------------------------------------------------------
# Add host overrides to /etc/hosts from numbered environment variables
# Supports CONTAINER_HOST_OVERRIDE_01, CONTAINER_HOST_OVERRIDE_02, etc.
host_override() {
  _hostnum=$(printenv | sort | grep -cE '^CONTAINER_HOST_OVERRIDE_([0-9].)')
  for (( _host = 01; _host <= _hostnum; _host++ )); do
    _host=$(printf "%02d" $_host)
    host_line=CONTAINER_HOST_OVERRIDE_${_host}
    host_ip=$(echo ${!host_line} | awk '{print $1}')

    # Resolve hostname to IP if not already an IP address
    if [[ ! "${host_ip}" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
      host_ip="$(getent ahostsv4 "${host_ip}" | grep -m 1 STREAM  | awk '{print $1}')"
    fi

    echo "# Added automatically by CONTAINER_HOST_OVERRIDE_${_host}" >> /etc/hosts
    echo "${host_ip} $(echo ${!host_line} | cut -d' ' -f2-)" >> /etc/hosts
  done
}

# Validate that required environment variables are set
# Args: $1 - variable name to check
#       $2 - human-readable description for error message
sanity_var() {
  output_off
  print_debug "Looking for existence of $1 environment variable"
  if [ ! -v "$1" ]; then
    print_error "No '$2' Entered! - Set '\$$1'"
    exit 1
  fi
  output_on
}

# Set system timezone with validation
# Args: $1 - timezone name (e.g., America/New_York)
set_timezone() {
  if [ -f /usr/share/zoneinfo/"${TIMEZONE}" ]; then
    if [ "${TIMEZONE}" != "$(cat /etc/timezone)" ]; then
      print_notice "Timezone: Setting to '${TIMEZONE}' from '$(cat /etc/timezone)'"
      cp -R /usr/share/zoneinfo/"${1}" /etc/localtime
      echo "${1}" > /etc/timezone
    fi
  else
    print_warn "Timezone: ${TIMEZONE} does not exist - Using '$(cat /etc/timezone)'"
  fi
}

#------------------------------------------------------------------------
# BOOLEAN CONVERSION UTILITY FUNCTIONS
#------------------------------------------------------------------------
# Convert true/false values to on/off format
# Args: $1 - variable name to convert
#       $2 - optional case specification (uppercase/lowercase)
truefalse_onoff() {
  value=$(set | grep "${1}"= | cut -d '=' -f2)
  var=$(set | grep "${1}"= | sed "s/=.*//g")

  if [ "${value,,}" = "true" ] || [ "${value,,}" = "yes" ]; then
    print_debug "Converting Variable Name ${var} value to 'On'"
    unset "$1"
    if [ -n "$2" ]; then
      case "${2,,}" in
        "uppercase" | "upper" | "uc" )
          export "$1=ON"
        ;;
        "lowercase" | "lower" | "lc" )
          export "$1=on"
        ;;
      esac
    else
      export "$1=ON"
    fi
  elif [ "${value,,}" = "false" ] || [ "${value,,}" = "no" ]; then
    print_debug "Converting Variable Name ${var} value to 'Off'"
    unset "$1"
    if [ -n "$2" ]; then
      case "${2,,}" in
        "uppercase" | "upper" | "uc" )
          export "$1=OFF"
        ;;
        "lowercase" | "lower" | "lc" )
          export "$1=off"
        ;;
      esac
    else
      export "$1=off"
    fi
  fi
}

# Convert true/false values to 1/0 format
# Args: $1 - variable name to convert
truefalse_onezero() {
  value=$(set | grep "${1}"= | cut -d '=' -f2)
  var=$(set | grep "${1}"= | sed "s/=.*//g")

  if [ "${value,,}" = "true" ] || [ "${value,,}" = "yes" ]; then
    print_debug "Converting Variable Name ${var} value to '1'"
    unset "$1"
    export "$1=1"
  elif [ "${value,,}" = "false" ] || [ "${value,,}" = "no" ]; then
    print_debug "Converting Variable Name ${var} value to '0'"
    unset "$1"
    export "$1=0"
  fi
}

# Convert true/false values to yes/no format
# Args: $1 - variable name to convert
#       $2 - optional case specification (uppercase/lowercase)
truefalse_yesno() {
  value=$(set | grep "${1}"= | cut -d '=' -f2)
  var=$(set | grep "${1}"= | sed "s/=.*//g")

  if [ "${value,,}" = "true" ] || [ "${value,,}" = "yes" ]; then
    print_debug "Converting Variable Name ${var} value to 'yes'"
    unset "$1"
    if [ -n "$2" ]; then
      case "${2,,}" in
        "uppercase" | "upper" | "uc" )
          export "$1=YES"
        ;;
        "lowercase" | "lower" | "lc" )
          export "$1=yes"
        ;;
      esac
    else
      export "$1=yes"
    fi
  elif [ "${value,,}" = "false" ] || [ "${value,,}" = "no" ]; then
    print_debug "Converting Variable Name ${var} value to 'no'"
    unset "$1"
    if [ -n "$2" ]; then
      case "${2,,}" in
        "uppercase" | "upper" | "uc" )
          export "$1=NO"
        ;;
        "lowercase" | "lower" | "lc" )
          export "$1=no"
        ;;
      esac
    else
      export "$1=no"
    fi
  fi
}

# Test if variable contains a false value
# Args: $1 - variable value to test
# Returns: 0 if false, 1 if not false
var_false() {
  [ "${1,,}" = "false" ] || [ "${1,,}" = "no" ]
}

# Test if variable does not contain a false value
# Args: $1 - variable value to test
# Returns: 0 if not false, 1 if false
var_notfalse() {
  [ "${1,,}" != "false" ]
}

# Test if variable does not contain a true value
# Args: $1 - variable value to test
# Returns: 0 if not true, 1 if true
var_nottrue() {
  [ "${1,,}" != "true" ]
}

# Test if variable contains a true value
# Args: $1 - variable value to test
# Returns: 0 if true, 1 if not true
var_true() {
  [ "${1,,}" = "true" ] || [ "${1,,}" = "yes" ]
}

# Convert yes/no values to true/false format
# Args: $1 - variable name to convert
#       $2 - optional case specification (uppercase/lowercase)
yesno_truefalse() {
  value=$(set | grep "${1}"= | cut -d '=' -f2)
  var=$(set | grep "${1}"= | sed "s/=.*//g")

  if [ "${value,,}" = "true" ] || [ "${value,,}" = "yes" ]; then
    print_debug "Converting Variable Name ${var} value to 'yes'"
    unset "$1"
    if [ -n "$2" ]; then
      case "${2,,}" in
        "uppercase" | "upper" | "uc" )
          export "$1=TRUE"
        ;;
        "lowercase" | "lower" | "lc" )
          export "$1=true"
        ;;
      esac
    else
      export "$1=TRUE"
    fi
  elif [ "${value,,}" = "false" ] || [ "${value,,}" = "no" ]; then
    print_debug "Converting Variable Name ${var} value to 'no'"
    unset "$1"
    if [ -n "$2" ]; then
      case "$2" in
        "uppercase" | "upper" | "uc" )
          export "$1=FALSE"
        ;;
        "lowercase" | "lower" | "lc" )
          export "$1=false"
        ;;
      esac
    else
      export "$1=FALSE"
    fi
  fi
}

#------------------------------------------------------------------------
# DATABASE CONNECTIVITY AND VALIDATION FUNCTIONS
#------------------------------------------------------------------------
# Wait for database service to become ready
# Supports multiple database types with appropriate connection testing
# Args: $1 - database type (mysql/postgres/redis/mongo/etc.)
db_ready() {
  output_off
  print_debug "Checking to see if Database Type $1 is ready"
  case "${1,,}" in
    "couch" | "couchdb" )
      # CouchDB connectivity check
      transform_file_var DB_PORT
      if [ -n "${DB_PORT}" ]; then couch_port=${DB_PORT}; fi;
      transform_file_var COUCHDB_PORT
      if [ -n "${COUCHDB_PORT}" ]; then couch_port=${COUCHDB_PORT}; fi;
      couch_port=${couch_port:-5984}
      transform_file_var DB_HOST
      if [ -n "${DB_HOST}" ]; then couch_host=${DB_HOST}; fi;
      transform_file_var COUCHDB_HOST
      if [ -n "${COUCHDB_HOST}" ]; then couch_host=${COUCHDB_HOST}; fi;
      counter=0
      # shellcheck disable=SC2086
      while ! (nc -z "${couch_host}" ${couch_port}); do
        sleep 5
        (( counter+=5 ))
        print_warn "CouchDB Host '${couch_host}' is not accessible, retrying.. ($counter seconds so far)"
      done
    ;;
    "influx" | "influxdb" )
      # InfluxDB connectivity check
      transform_file_var DB_PORT
      if [ -n "${DB_PORT}" ]; then influx_port=${DB_PORT}; fi;
      transform_file_var INFLUXDB_PORT
      if [ -n "${INFLUXDB_PORT}" ]; then influx_port=${INFLUXDB_PORT}; fi;
      influx_port=${influx_port:-8088}
      transform_file_var DB_HOST
      if [ -n "${DB_HOST}" ]; then influx_host=${DB_HOST}; fi;
      transform_file_var INFLUXDB_HOST
      if [ -n "${INFLUXDB_HOST}" ]; then influx_host=${INFLUXDB_HOST}; fi;
      counter=0
      while ! (nc -z "${influx_host}" "${influx_port}"); do
        sleep 5
        (( counter+=5 ))
        print_warn "InfluxDB Host '${influx_host}' is not accessible, retrying.. ($counter seconds so far)"
      done
    ;;
    "mongo" | "mongodb" )
      # MongoDB connectivity check
      transform_file_var DB_PORT
      if [ -n "${DB_PORT}" ]; then mongo_port=${DB_PORT}; fi;
      transform_file_var MONGO_PORT
      if [ -n "${MONGO_PORT}" ]; then mongo_port=${MONGO_PORT}; fi;
      mongo_port=${mongo_port:-27017}
      transform_file_var DB_HOST
      if [ -n "${DB_HOST}" ]; then mongo_host=${DB_HOST}; fi;
      transform_file_var MONGO_HOST
      if [ -n "${MONGO_HOST}" ]; then mongo_host=${MONGO_HOST}; fi;
      counter=0
      while ! (nc -z "${mongo_host}" "${mongo_port}"); do
        sleep 5
        (( counter+=5 ))
        print_warn "Mongo Host '${mongo_host}' is not accessible, retrying.. ($counter seconds so far)"
      done
    ;;
    "mysql" | "mariadb" )
      # MySQL/MariaDB connectivity check with client detection
      if command -v "mariadb-admin" &> /dev/null; then
        mysqladmin_bin="$(which mariadb-admin)"
      elif command -v "mysqladmin" &> /dev/null; then
        mysqladmin_bin="$(which mysqladmin)"
      else
        print_error "No MySQL or MariaDB client detected - Cannot check for Database"
        exit 1
      fi

      # Disable SSL for client connections to avoid certificate issues
      if [ ! -f /etc/my.cnf.d/disable-ssl.cnf ]; then
        cat <<EOF > /etc/my.cnf.d/disable-ssl.cnf
[client]
ssl=FALSE
EOF
      fi

      # Resolve connection parameters with multiple naming conventions
      transform_file_var DB_PORT
      if [ -n "${DB_PORT}" ]; then maria_port=${DB_PORT}; fi;
      transform_file_var MYSQL_PORT
      if [ -n "${MYSQL_PORT}" ]; then maria_port=${MYSQL_PORT}; fi;
      transform_file_var MARIA_PORT
      if [ -n "${MARIA_PORT}" ]; then maria_port=${MARIA_PORT}; fi;
      maria_port=${maria_port:-3306}
      transform_file_var DB_HOST
      if [ -n "${DB_HOST}" ]; then maria_host=${DB_HOST}; fi;
      transform_file_var MYSQL_PORT
      if [ -n "${MYSQL_HOST}" ]; then maria_host=${MYSQL_HOST}; fi;
      transform_file_var MARIA_PORT
      if [ -n "${MARIA_HOST}" ]; then maria_host=${MARIA_HOST}; fi;
      transform_file_var DB_USER
      if [ -n "${DB_USER}" ]; then maria_user=${DB_USER}; fi;
      transform_file_var MYSQL_USER
      if [ -n "${MYSQL_USER}" ]; then maria_user=${MYSQL_USER}; fi;
      transform_file_var MARIA_USER
      if [ -n "${MARIA_USER}" ]; then maria_user=${MARIA_USER}; fi;
      transform_file_var DB_PASS
      if [ -n "${DB_PASS}" ]; then maria_pass=${DB_PASS}; fi;
      transform_file_var MYSQL_PASS
      if [ -n "${MYSQL_PASS}" ]; then maria_pass=${MYSQL_PASS}; fi;
      transform_file_var MARIA_PASS
      if [ -n "${MARIA_PASS}" ]; then maria_pass=${MARIA_PASS}; fi;
      transform_file_var DB_NAME
      if [ -n "${DB_NAME}" ]; then maria_name=${DB_NAME}; fi;
      transform_file_var MYSQL_NAME
      if [ -n "${MYSQL_NAME}" ]; then maria_name=${MYSQL_NAME}; fi;
      transform_file_var MARIA_NAME
      if [ -n "${MARIA_NAME}" ]; then maria_name=${MARIA_NAME}; fi;
      counter=0
      while ! ("${mysqladmin_bin}" -u"${maria_user}" -P"${maria_port}" -h"${maria_host}" -p"${maria_pass}" status > /dev/null 2>&1); do
        sleep 5
        (( counter+=5 ))
        print_warn "MySQL/MariaDB Server '${maria_host}' is not accessible, retrying.. (${counter} seconds so far)"
      done
    ;;
    "pgsql" | "psql" | "postgres" | "postgresql" )
      # PostgreSQL connectivity check using pg_isready
      if command -v "pg_isready" &> /dev/null; then
        pg_isready_bin="$(which pg_isready)"
      else
        print_error "No Postgresql client installation installation detected - Cannot check for Database"
        exit 1
      fi

      # Resolve PostgreSQL connection parameters
      transform_file_var DB_PORT
      if [ -n "${DB_PORT}" ]; then postgres_port=${DB_PORT}; fi;
      transform_file_var POSTGRES_HOST
      if [ -n "${POSTGRES_PORT}" ]; then postgres_port=${POSTGRES_PORT}; fi;
      postgres_port=${postgres_port:-5432}
      transform_file_var DB_HOST
      if [ -n "${DB_HOST}" ]; then postgres_host=${DB_HOST}; fi;
      transform_file_var POSTGRES_HOST
      if [ -n "${POSTGRES_HOST}" ]; then postgres_host=${POSTGRES_HOST}; fi;
      transform_file_var DB_USER
      if [ -n "${DB_USER}" ]; then postgres_user=${DB_USER}; fi;
      transform_file_var POSTGRES_USER
      if [ -n "${POSTGRES_USER}" ]; then postgres_user=${POSTGRES_USER}; fi;
      transform_file_var DB_PASS
      if [ -n "${DB_PASS}" ]; then postgres_pass=${DB_PASS}; fi;
      transform_file_var PGPASSWORD
      if [ -n "${PGPASSWORD}" ]; then postgres_pass=${PGPASSWORD}; fi;
      transform_file_var DB_NAME
      if [ -n "${DB_NAME}" ]; then postgres_name=${DB_NAME}; fi;
      transform_file_var POSTGRES_NAME
      if [ -n "${POSTGRES_NAME}" ]; then postgres_name=${POSTGRES_NAME}; fi;
      counter=0
      export PGPASSWORD=${postgres_pass}
      until "${pg_isready_bin}" --dbname="${postgres_name}" --host="${postgres_host}" --port="${postgres_port}" --username="${postgres_user}" -q; do
        sleep 5
        (( counter+=5 ))
        print_warn "Postgres Host '${postgres_host}' is not accessible, retrying.. ($counter seconds so far)"
      done
    ;;
    "rabbit" | "rabbitmq" )
      # RabbitMQ connectivity check
      transform_file_var DB_PORT
      if [ -n "${DB_PORT}" ]; then rabbit_port=${DB_PORT}; fi;
      transform_file_var RABBIT_PORT
      if [ -n "${RABBIT_PORT}" ]; then rabbit_port=${RABBIT_PORT}; fi;
      rabbit_port=${rabbit_port:-5672}
      transform_file_var DB_HOST
      if [ -n "${DB_HOST}" ]; then rabbit_host=${DB_HOST}; fi;
      transform_file_var RABBIT_HOST
      if [ -n "${RABBIT_HOST}" ]; then rabbit_host=${RABBIT_HOST}; fi;
      counter=0
      while ! (nc -z "${rabbit_host}" "${rabbit_port}"); do
        sleep 5
        (( counter+=5 ))
        print_warn "RabbitMQ Host '${rabbit_host}' is not accessible, retrying.. ($counter seconds so far)"
      done
    ;;
    "redis" )
      # Redis connectivity check
      transform_file_var DB_PORT
      if [ -n "${DB_PORT}" ]; then redis_port=${DB_PORT}; fi;
      if [ -n "${DB_PORT_FILE}" ]; then couch_port="$(cat "${DB_PORT_FILE}")"; fi;
      if [ -n "${REDIS_PORT}" ]; then redis_port=${REDIS_PORT}; fi;
      redis_port=${redis_port:-6379}
      if [ -n "${DB_HOST}" ]; then redis_host=${DB_HOST}; fi;
      if [ -n "${REDIS_HOST}" ]; then redis_host=${REDIS_HOST}; fi;
      counter=0
      while ! (nc -z "${redis_host}" "${redis_port}"); do
        sleep 5
        (( counter+=5 ))
        print_warn "Redis Host '${redis_host}' is not accessible, retrying.. ($counter seconds so far)"
      done
    ;;
    "rethink" )
      # RethinkDB connectivity check
      transform_file_var DB_PORT
      if [ -n "${DB_PORT}" ]; then rethink_port=${DB_PORT}; fi;
      if [ -n "${DB_PORT_FILE}" ]; then couch_port="$(cat "${DB_PORT_FILE}")"; fi;
      if [ -n "${RETHINK_PORT}" ]; then rethink_port=${RETHINK_PORT}; fi;
      rethink_port=${rethink_port:-28015}
      if [ -n "${DB_HOST}" ]; then rethink_host=${DB_HOST}; fi;
      if [ -n "${RETHINK_HOST}" ]; then rethink_host=${RETHINK_HOST}; fi;
      counter=0
      while ! (nc -z "${rethink_host}" "${rethink_port}"); do
        sleep 5
        (( counter+=5 ))
        print_warn "RethinkDB Host '${DB_HOST}' is not accessible, retrying.. ($counter seconds so far)"
      done
    ;;
  esac
  output_on
}

# Validate required database configuration parameters
# Checks that all necessary environment variables are set for database type
# Args: $1 - database type to validate
sanity_db() {
  output_off
  if [ -n "$1" ]; then
    case "${1,,}" in
      "couch" | "couchdb" )
        print_debug "Checking Couch DB Parameters"
        transform_file_var DB_HOST
        if [ -n "${DB_HOST}" ]; then couch_host=${DB_HOST}; fi;
        transform_file_var COUCH_HOST
        if [ -n "${COUCH_HOST}" ]; then couch_host=${COUCH_HOST}; fi;
        if [ -z "${couch_host}" ]; then
          print_error "No Couch Database Host Entered! - Set '\$DB_HOST' or '\$COUCH_HOST'"
          exit 1
        fi
      ;;
      "influx" | "influxdb")
        print_debug "Checking Influx DB Parameters"
        if [ -n "${DB_HOST}" ]; then influx_host=${DB_HOST}; fi;
        transform_file_var DB_HOST
        if [ -n "${INFLUX_HOST}" ]; then influx_host=${INFLUX_HOST}; fi;
        transform_file_var INFLUX_HOST
        if [ -z "${influx_host}" ]; then
          print_error "No Influx Database Host Entered! - Set '\$DB_HOST' or '\$INFLUX_HOST'"
          exit 1
        fi
      ;;
      "mongo" | "mongodb" )
        print_debug "Checking Mongo DB Parameters"
        if [ -n "${DB_HOST}" ]; then mongo_host=${DB_HOST}; fi;
        transform_file_var DB_HOST
        if [ -n "${MONGO_HOST}" ]; then mongo_host=${MONGO_HOST}; fi;
        transform_file_var MONGO_HOST
        if [ -z "${mongo_host}" ]; then
          print_error "No Mongo Database Host Entered! - Set '\$DB_HOST' or '\$MONGO_HOST'"
          exit 1
        fi
      ;;
      "mysql" | "mariadb" )
        print_debug "Checking MariaDB DB Parameters"
        transform_file_var DB_HOST
        if [ -n "${DB_HOST}" ]; then maria_host=${DB_HOST}; fi;
        transform_file_var MYSQL_HOST
        if [ -n "${MYSQL_HOST}" ]; then maria_host=${MYSQL_HOST}; fi;
        transform_file_var MARIA_HOST
        if [ -n "${MARIA_HOST}" ]; then maria_host=${MARIA_HOST}; fi;
        transform_file_var DB_USER
        if [ -n "${DB_USER}" ]; then maria_user=${DB_USER}; fi;
        transform_file_var MYSQL_USER
        if [ -n "${MYSQL_USER}" ]; then maria_user=${MYSQL_USER}; fi;
        transform_file_var MARIA_USER
        if [ -n "${MARIA_USER}" ]; then maria_user=${MARIA_USER}; fi;
        transform_file_var DB_PASS
        if [ -n "${DB_PASS}" ]; then maria_pass=${DB_PASS}; fi;
        transform_file_var MYSQL_PASS
        if [ -n "${MYSQL_PASS}" ]; then maria_pass=${MYSQL_PASS}; fi;
        transform_file_var MARIA_PASS
        if [ -n "${MARIA_PASS}" ]; then maria_pass=${MARIA_PASS}; fi;
        transform_file_var DB_NAME
        if [ -n "${DB_NAME}" ]; then maria_name=${DB_NAME}; fi;
        transform_file_var MYSQL_NAME
        if [ -n "${MYSQL_NAME}" ]; then maria_name=${MYSQL_NAME}; fi;
        transform_file_var MARIA_NAME
        if [ -n "${MARIA_NAME}" ]; then maria_name=${MARIA_NAME}; fi;
        if [ -z "${maria_host}" ]; then
          print_error "No MariaDB Database Host Entered! - Set '\$DB_HOST' or '\$MARIA_HOST'"
          exit 1
        fi
        if [ -z "${maria_name}" ]; then
          print_error "No MariaDB Database Name Entered! - Set '\$DB_NAME' or '\$MARIA_NAME'"
          exit 1
        fi
        if [ -z "${maria_user}" ]; then
          print_error "No MariaDB Database USER Entered! - Set '\$DB_USER' or '\$MARIA_USER'"
          exit 1
        fi
        if [ -z "${maria_pass}" ]; then
          print_error "No MariaDB Database Pass Entered! - Set '\$DB_PASS' or '\$MARIA_PASS'"
          exit 1
        fi
      ;;
      "pgsql" | "psql" | "postgres" | "postgresql" )
        print_debug "Checking Postgres DB Parameters"
        transform_file_var DB_HOST
        if [ -n "${DB_HOST}" ]; then postgres_host=${DB_HOST}; fi;
        transform_file_var POSTGRES_HOST
        if [ -n "${POSTGRES_HOST}" ]; then postgres_host=${POSTGRES_HOST}; fi;
        transform_file_var DB_USER
        if [ -n "${DB_USER}" ]; then postgres_user=${DB_USER}; fi;
        transform_file_var POSTGRES_USER
        if [ -n "${POSTGRES_USER}" ]; then postgres_user=${POSTGRES_USER}; fi;
        transform_file_var DB_PASS
        if [ -n "${DB_PASS}" ]; then postgres_pass=${DB_PASS}; fi;
        transform_file_var PGPASSWORD
        if [ -n "${PGPASSWORD}" ]; then postgres_pass=${PGPASSWORD}; fi;
        transform_file_var DB_NAME
        if [ -n "${DB_NAME}" ]; then postgres_name=${DB_NAME}; fi;
        transform_file_var POSTGRES_NAME
        if [ -n "${POSTGRES_NAME}" ]; then postgres_name=${POSTGRES_NAME}; fi;
        if [ -z "${postgres_host}" ]; then
          print_error "No PostgreSQL Database Host Entered! - Set '\$DB_HOST' or '\$POSTGRES_HOST'"
          exit 1
        fi
        if [ -z "${postgres_name}" ]; then
          print_error "No PostgreSQL Database Name Entered! - Set '\$DB_NAME' or '\$POSTGRES_NAME'"
          exit 1
        fi
        if [ -z "${postgres_user}" ]; then
          print_error "No PostgreSQL Database USER Entered! - Set '\$DB_USER' or '\$POSTGRES_USER'"
          exit 1
        fi
        if [ -z "${postgres_pass}" ]; then
          print_error "No PostgreSQL Database Pass Entered! - Set '\$DB_PASS' or '\$POSTGRES_PASS'"
          exit 1
        fi
      ;;
      "rabbit" | "rabbitmq" )
        transform_file_var DB_HOST
        if [ -n "${DB_HOST}" ]; then rabbit_host=${DB_HOST}; fi;
        transform_file_var RABBIT_HOST
        if [ -n "${RABBIT_HOST}" ]; then rabbit_host=${RABBIT_HOST}; fi;
        transform_file_var RABBITMQ_HOST
        if [ -n "${RABBITMQ_HOST}" ]; then rabbit_host=${RABBITMQ_HOST}; fi;
        if [ -z "${rabbit_host}" ]; then
          print_error "No RabbitMQ Database Host Entered! - Set '\$DB_HOST' or '\$RABBIT_HOST'"
          exit 1
        fi
      ;;
      "redis" )
        print_debug "Checking Redis DB Parameters"
        transform_file_var DB_HOST
        if [ -n "${DB_HOST}" ]; then redis_host=${DB_HOST}; fi;
        transform_file_var REDIS_HOST
        if [ -n "${REDIS_HOST}" ]; then redis_host=${REDIS_HOST}; fi;
        if [ -z "${redis_host}" ]; then
          print_error "No Redis Database Host Entered! - Set '\$DB_HOST' or '\$REDIS_HOST'"
          exit 1
        fi
      ;;
      "rethink" )
        print_debug "Checking RethinkDB DB Parameters"
        transform_file_var DB_HOST
        if [ -n "${DB_HOST}" ]; then rethink_host=${DB_HOST}; fi;
        transform_file_var RETHINK_HOST
        if [ -n "${RETHINK_HOST}" ]; then rethink_host=${RETHINK_HOST}; fi;
        if [ -z "${rethink_host}" ]; then
          print_error "No Rethink Database Host Entered! - Set '\$DB_HOST' or '\$RETHINK_HOST'"
          exit 1
        fi
      ;;
    esac
    output_on
  else
    # Legacy mode - validate generic database parameters
    print_debug "Using Legacy db_ready command - please upgrade"
    transform_file_var DB_HOST
    if [ -z "${DB_HOST}" ]; then
      print_error "No Database Host Entered! - Set '\$DB_HOST'"
      exit 1
    fi

    transform_file_var DB_NAME
    if [ -z "${DB_NAME}" ]; then
      print_error "No Database Name Entered! - Set '\$DB_NAME'"
      exit 1
    fi

    transform_file_var DB_USER
    if [ -z "${DB_USER}" ]; then
      print_error "No Database User Entered! - Set '\$DB_USER'"
      exit 1
    fi

    transform_file_var DB_PASS
    if [ -z "${DB_PASS}" ]; then
      print_error "No Database Password Entered! - Set '\$DB_PASS'"
      exit 1
    fi
    output_on
  fi
}

#------------------------------------------------------------------------
# PRIVILEGE MANAGEMENT FUNCTIONS
#------------------------------------------------------------------------
# Grant doas (sudo alternative) privileges to a user
# Args: $1 - username to grant privileges
#       $2 - optional specific command to allow
grant_doas() {
  output_off
  if [ -n "$1" ]; then
    print_debug "Adding Doas privileges to '$1'"
    if [ -n "$2" ]; then
      print_debug="Adding doas privileges to '$1' for '${doas_command}' command"
      doas_command="cmd $2"
    else
      doas_command=""
    fi

    echo "permit nopass $1 ${doas_command} as root" >> /etc/doas.conf
    chown root:root /etc/doas.conf
    chmod 0400 -R /etc/doas.conf
  fi
  output_on
}

# Grant sudo privileges to a user
# Args: $1 - username to grant privileges
#       $2 - optional specific command to allow (defaults to ALL)
grant_sudo() {
  output_off
  if [ -n "$1" ]; then
    if [ -n "$2" ]; then
      sudo_command="$2"
    else
      sudo_command="ALL"
    fi
    print_debug "Adding Sudo privileges to '$1' for '${sudo_command}' command"
    echo "%$1 ALL=(ALL) NOPASSWD:${sudo_command}" >> /etc/sudoers
  fi
  output_on
}

#------------------------------------------------------------------------
# MONITORING INTEGRATION FUNCTIONS
#------------------------------------------------------------------------
# Create Zabbix monitoring configuration for a service
# Args: $1 - service name
#       $2 - optional autoregister name (defaults to $1)
create_zabbix() {
  if [ -n "$1" ]; then
    if [ -n "$2" ]; then
      autoregister=$2
    else
      autoregister=$1
    fi
    print_debug "Adding Zabbix Auto Register configuration for '$1'"
    if var_true "${CONTAINER_ENABLE_MONITORING}" && [ "${CONTAINER_MONITORING_BACKEND,,}" = "zabbix" ]; then
      source /assets/defaults/03-monitoring
      cat <<EOF > "${ZABBIX_CONFIG_PATH}"/"${ZABBIX_CONFIG_FILE}.d"/focela_"$1".conf
# Zabbix $1 Configuration - Automatically Generated
# Autoregister=$autoregister
EOF
    fi
  fi
}

#------------------------------------------------------------------------
# PACKAGE MANAGEMENT ABSTRACTION
#------------------------------------------------------------------------
# Cross-platform package management function
# Automatically detects OS and uses appropriate package manager
# Supports: install, remove, update, upgrade, cleanup
package() {
  # Cleanup function for removing package manager caches
  cleanup() {
    case "${distro}" in
      "alpine" )
        rm -rf /root/.gitconfig
        rm -rf /var/cache/apk/*
      ;;
      "debian" | "ubuntu" )
        apt-get clean -y
        rm -rf /root/.gitconfig
        rm -rf /var/lib/apt/lists/*
      ;;
    esac
  }

  # Install packages with optional build dependencies
  install() {
    case "${distro}" in
      "alpine" )
        # Support .build-deps pattern for temporary packages
        if [[ "${1}" =~ ^\..* ]]; then
          local dependencies="-t"
        fi
        apk add ${dependencies} $@
      ;;
      "debian" | "ubuntu" )
        if [[ "${1}" =~ ^\..* ]]; then
          shift
        fi
        apt-get install -y --no-install-recommends $@
      ;;
    esac
  }

  # Remove packages and dependencies
  remove() {
    case "${distro}" in
      "alpine" )
        apk del $@
      ;;
      "debian" | "ubuntu" )
        local packages="$@"
        # Handle .build-deps pattern removal
        if [[ "${packages}" =~ \..* ]]; then
          packages=$(echo "${packages}" | sed "s|\..* ||g")
        fi
        apt-get purge -y ${packages}
        apt-get autoremove -y
      ;;
    esac
  }

  # Update package repository indexes
  update() {
    case "${distro}" in
      "alpine" )
        apk update
      ;;
      "debian" | "ubuntu" )
        apt-get update
      ;;
    esac
  }

  # Upgrade all installed packages
  upgrade() {
    case "${distro}" in
      "alpine" )
        apk upgrade
      ;;
      "debian" | "ubuntu" )
        apt-get upgrade -y
      ;;
    esac
  }

  output_off
  local distro
  distro=$(cat /etc/os-release |grep ^ID= | cut -d = -f2)
  local action="${1}"
  shift
  local arguments=$@

  # Map action aliases to standard function names
  case "${action}" in
    add | install )
      action=install
      "${action}" "${arguments}"
    ;;
    delete | remove | uninstall )
      action=remove
      "${action}" "${arguments}"
    ;;
    * )
      "${action}" "${arguments}"
    ;;
  esac
  output_on
}

#------------------------------------------------------------------------
# DEBUG MODE CONFIGURATION
#------------------------------------------------------------------------
# Configure debug mode based on DEBUG_MODE environment variable
# Supports global debug, per-script debug, or specific service debug
case "${DEBUG_MODE}" in
  "TRUE" | "true" | "YES" | "yes" | "ON" | "on" )
    # Global debug mode - enable for all scripts
    CONTAINER_LOG_LEVEL="DEBUG"
    set -x
  ;;
  "FALSE" | "false" | "NO" | "no" | "OFF" | "off" )
    # Debug explicitly disabled
    :
  ;;
  * )
    # Selective debug mode - enable for specific scripts only
    if [ "$(dirname "$0")" = "/var/run/s6/etc/cont-init.d" ] || [ "$(dirname "$0")" = "/etc/cont-init.d" ]; then
      # Enable debug for specific initialization script
      if [ "${DEBUG_MODE}" = "$(basename \""$0"\")" ]; then
        print_notice "Enabling Debug mode for $(basename \""$0"\") scripts"
        set -x
      fi
    fi
    # Enable debug for specific service
    if [ "${DEBUG_MODE}" = "$(basename "$PWD")" ]; then
      print_notice "Enabling Debug mode for $(basename "$PWD") scripts"
      set -x
    fi
  ;;
esac
